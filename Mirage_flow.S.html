<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Mirage_flow.ABSTRACT.html">
<link rel="next" href="Mirage_flow.CONCRETE.html">
<link rel="Up" href="Mirage_flow.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Mirage_flow" rel="Chapter" href="Mirage_flow.html">
<link title="Mirage_flow_lwt" rel="Chapter" href="Mirage_flow_lwt.html">
<link title="Mirage_flow_unix" rel="Chapter" href="Mirage_flow_unix.html"><title>Mirage_flow.S</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Mirage_flow.ABSTRACT.html" title="Mirage_flow.ABSTRACT">Previous</a>
&nbsp;<a class="up" href="Mirage_flow.html" title="Mirage_flow">Up</a>
&nbsp;<a class="post" href="Mirage_flow.CONCRETE.html" title="Mirage_flow.CONCRETE">Next</a>
</div>
<h1>Module type <a href="type_Mirage_flow.S.html">Mirage_flow.S</a></h1>

<pre><span class="keyword">module type</span> S = <code class="type"><a href="Mirage_flow.ABSTRACT.html">ABSTRACT</a></code><code class="type">  with type write_error = private [> write_error ]</code></pre><div class="info modtype top">
The main <code class="code"><span class="constructor">FLOW</span></code> signature, where <code class="code">write_errors</code> is a private row
    type. Note: ideally <code class="code">error</code> should be the empty row, but not easy
    way to express this in OCaml.<br>
</div>
<hr width="100%">

<pre><span id="TYPEio"><span class="keyword">type</span> <code class="type">+'a</code> io</span> </pre>
<div class="info ">
The type for potentially blocking I/O operations.<br>
</div>


<pre><span id="TYPEerror"><span class="keyword">type</span> <code class="type"></code>error</span> </pre>
<div class="info ">
The type for flow errors.<br>
</div>


<pre><span id="VALpp_error"><span class="keyword">val</span> pp_error</span> : <code class="type"><a href="Mirage_flow.ABSTRACT.html#TYPEerror">error</a> Fmt.t</code></pre><div class="info ">
<code class="code">pp_error</code> is the pretty-printer for errors.<br>
</div>

<pre><span id="TYPEwrite_error"><span class="keyword">type</span> <code class="type"></code>write_error</span> </pre>
<div class="info ">
The type for write errors.<br>
</div>


<pre><span id="VALpp_write_error"><span class="keyword">val</span> pp_write_error</span> : <code class="type"><a href="Mirage_flow.ABSTRACT.html#TYPEwrite_error">write_error</a> Fmt.t</code></pre><div class="info ">
<code class="code">pp_write_error</code> is the pretty-printer for write errors.<br>
</div>

<pre><span id="TYPEbuffer"><span class="keyword">type</span> <code class="type"></code>buffer</span> </pre>
<div class="info ">
The type for memory buffer.<br>
</div>


<pre><span id="TYPEflow"><span class="keyword">type</span> <code class="type"></code>flow</span> </pre>
<div class="info ">
The type for flows. A flow represents the state of a single
      reliable stream that is connected to an endpoint.<br>
</div>


<pre><span id="VALread"><span class="keyword">val</span> read</span> : <code class="type"><a href="Mirage_flow.ABSTRACT.html#TYPEflow">flow</a> -><br>       (<a href="Mirage_flow.ABSTRACT.html#TYPEbuffer">buffer</a> <a href="Mirage_flow.html#TYPEor_eof">Mirage_flow.or_eof</a>, <a href="Mirage_flow.ABSTRACT.html#TYPEerror">error</a>)<br>       Result.result <a href="Mirage_flow.ABSTRACT.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">read&nbsp;flow</code> blocks until some data is available and returns a
      fresh buffer containing it.
<p>

      The returned buffer will be of a size convenient to the flow
      implementation, but will always have at least 1 byte.
<p>

      If the remote endpoint calls <code class="code">close</code> then calls to <code class="code">read</code> will
      keep returning data until all the in-flight data has been read.
      <code class="code">read&nbsp;flow</code> will return <code class="code"><span class="keywordsign">`</span><span class="constructor">Eof</span></code> when the remote endpoint has
      called <code class="code">close</code> and when there is no more in-flight data.<br>
</div>

<pre><span id="VALwrite"><span class="keyword">val</span> write</span> : <code class="type"><a href="Mirage_flow.ABSTRACT.html#TYPEflow">flow</a> -><br>       <a href="Mirage_flow.ABSTRACT.html#TYPEbuffer">buffer</a> -><br>       (unit, <a href="Mirage_flow.ABSTRACT.html#TYPEwrite_error">write_error</a>) Result.result<br>       <a href="Mirage_flow.ABSTRACT.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">write&nbsp;flow&nbsp;buffer</code> writes a buffer to the flow. There is no
      indication when the buffer has actually been read and, therefore,
      it must not be reused.  The contents may be transmitted in
      separate packets, depending on the underlying transport. The
      result <code class="code"><span class="constructor">Ok</span>&nbsp;()</code> indicates success, <code class="code"><span class="constructor">Error</span>&nbsp;<span class="keywordsign">`</span><span class="constructor">Closed</span></code> indicates that the
      connection is now closed and therefore the data could not be
      written.  Other errors are possible.<br>
</div>

<pre><span id="VALwritev"><span class="keyword">val</span> writev</span> : <code class="type"><a href="Mirage_flow.ABSTRACT.html#TYPEflow">flow</a> -><br>       <a href="Mirage_flow.ABSTRACT.html#TYPEbuffer">buffer</a> list -><br>       (unit, <a href="Mirage_flow.ABSTRACT.html#TYPEwrite_error">write_error</a>) Result.result<br>       <a href="Mirage_flow.ABSTRACT.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">writev&nbsp;flow&nbsp;buffers</code> writes a sequence of buffers to the flow.
      There is no indication when the buffers have actually been read and,
      therefore, they must not be reused. The
      result <code class="code"><span class="constructor">Ok</span>&nbsp;()</code> indicates success, <code class="code"><span class="constructor">Error</span>&nbsp;<span class="keywordsign">`</span><span class="constructor">Closed</span></code> indicates that the
      connection is now closed and therefore the data could not be
      written.  Other errors are possible.<br>
</div>

<pre><span id="VALclose"><span class="keyword">val</span> close</span> : <code class="type"><a href="Mirage_flow.ABSTRACT.html#TYPEflow">flow</a> -> unit <a href="Mirage_flow.ABSTRACT.html#TYPEio">io</a></code></pre><div class="info ">
<code class="code">close&nbsp;flow</code> flushes all pending writes and signals the remote
      endpoint that there will be no future writes. Once the remote endpoint
      has read all pending data, it is expected that calls to <code class="code">read</code> on
      the remote return <code class="code"><span class="keywordsign">`</span><span class="constructor">Eof</span></code>.
<p>

      Note it is still possible for the remote endpoint to <code class="code">write</code> to
      the flow and for the local endpoint to call <code class="code">read</code>. This state where
      the local endpoint has called <code class="code">close</code> but the remote endpoint
      has not called <code class="code">close</code> is similar to that of a half-closed TCP
      connection or a Unix socket after <code class="code">shutdown(<span class="constructor">SHUTDOWN_WRITE</span>)</code>.
<p>

      <code class="code">close&nbsp;flow</code> waits until the remote endpoint has also called <code class="code">close</code>
      before returning. At this point no data can flow in either direction
      and resources associated with the flow can be freed.<br>
</div>
</body></html>